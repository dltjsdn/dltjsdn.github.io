---
layout: post
title:  "PSPNet(CVPR 2017 Paper 논문 리뷰 및 코드 분석)"
date:   2020-10-1T14:25:52-05:00
author: Sunwoo Lee
categories: Paper
---

### PSPNet(Pyramid Scene Parsing Network)

<br/>

ESPNet, ICNet으로 segmentation을 진행하면서 PSPNet에 대한 언급이 많아서 한번 리뷰를 해보려고 한다. 

![PSP1](https://user-images.githubusercontent.com/47741696/102001208-af154d00-3d32-11eb-89d2-e1a523f585b4.PNG)

이 논문은 기존에 Segmentation에서 많이 사용 되었던 FCN이 성능은 좋지만 많은 class를 표현하기에는 힘들다라고 표현을 한다. 이를 해결하기 위해서  ESPNet처럼 Dilated convolution 사용을 한다. ESPNet(링크)에서 설명한 것처럼 Dilated convolution은 Receptive Field가 커지기 때문에 이미지 전체의 feature를 뽑아내는데 더 유리하다. 

<br/>

#### Pyramid Pooling Module

![PSP2](https://user-images.githubusercontent.com/47741696/102001373-074d4e80-3d35-11eb-85a5-56494cdf1b4a.PNG)

전체적인 architecture를 확인하면 이해가 더 쉽다. 먼저 Input Image에서 CNN을 통해서 Feature Map을 뽑아내는데 여기서 Resnet과 Dilated Convolution을 사용한 FCN구조를 사용한다. 이후 Pyramid Pooling Module을 3단계로 적용한다.

- 4개의 서로 다른 크기로 pooling을 한다. 논문에서는 1x1, 2x2, 3x3, 6x6으로 사이즈를 만들었다. 1x1은 image에서 가장 거칠고 넓은 정보를 담고 크기가 커질수록 구체적인 정보를 가지게 된다.
- 1x1 convolution(Point-wise convolution)을 통해서 Channel수를 변경하고 모듈의 Input size에 맞춰서 Upsample한다.
- 마지막으로 기존의 Feature Map과 Concat을 하여 최종 ouput을 내보낸다. 

<br/>

```
class PSPModule(nn.Module):
    def __init__(self, features, out_features=1024, sizes=(1, 2, 3, 6)):
        super().__init__()
        self.stages = []
        self.stages = nn.ModuleList([self._make_stage(features, size) for size in sizes])
        self.bottleneck = nn.Conv2d(features * (len(sizes) + 1), out_features, kernel_size=1)
        self.relu = nn.ReLU()

    def _make_stage(self, features, size):
        prior = nn.AdaptiveAvgPool2d(output_size=(size, size))
        conv = nn.Conv2d(features, features, kernel_size=1, bias=False)
        return nn.Sequential(prior, conv)

    def forward(self, feats):
        h, w = feats.size(2), feats.size(3)
        priors = [F.upsample(input=stage(feats), size=(h, w), mode='bilinear') for stage in self.stages] + [feats]
        bottle = self.bottleneck(torch.cat(priors, 1))
        return self.relu(bottle)
```

Pytorch 코드로 보면 ModuleList에 4개의 Stages의 Feature Map Pooling 정보들을 담고 마지막에 bilinear를 통해서 Upsample하여 output으로 내보내는 것을 확인할 수 있다. 

<br/>

![PSP4](https://user-images.githubusercontent.com/47741696/102001603-4e3c4380-3d37-11eb-92c7-1890081a24ab.PNG)

최종 결과를 보면 다른 알고리즘들에 비해서 상당히 높은 IoU를 보여주는 것을 확인 할 수 있다. 

`본 논문에서 PSP Module 말고도 Loss를 나눠서 가중치로 최종적인 Loss를 산출하는 내용이 나오는데 관련된 나용은 ICNet()에 자세하게 포스팅을 했으니 참고하면 된다.` 