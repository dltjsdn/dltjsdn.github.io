---
layout: post
title:  "ESPNet(CVPR 2018 Paper 논문 리뷰 및 Pytorch 코드 분석)"
date:   2020-08-15T14:25:52-05:00
author: Sunwoo Lee
categories: Paper
tags: lorem ipsum
---



#### ESPNet: Efficient Spatial Pyramid of Dilarted Convolutions for Semantic Segmentation

<br/>

2018년에 CVPR에 소개된 이 Paper는 최근 딥러닝 Accuracy를 높히기 위해서 CNN 모델이 깊어지면서  이에 비례하여 너무 많은 계산량이 생겨 자율자동차나 로봇 그리고 실시간성을 중요로 하는 모델에는 부적합하다고 한다. 

이를 해결하기 위해서 **fast, small, low power 그리고 low latency를 가진 ESPNet을 제안**하였다. 

ESPNet은 낮은 메모리로 성능을 유지하기 위해서 2가지 Convolution을 활용하였는데 Point-wise convolutions과 Spatial pyramid of dilated convolutions이다. 

![ESP0](https://user-images.githubusercontent.com/47741696/102000447-e41da180-3d2a-11eb-975b-547d97c4e5ac.png)

먼저 Point-wise convolution은 위의 그림처럼 input의 Spatial Feature에 대해서는 추출하지 않고 **1x1xC 크기의 커널을 사용하여 채널들에 대한 연산만 수행**한다. 이렇게 출력되는 채널 수를 줄이면서 다음레이어의 계산량과 파라미터를 줄인다. ESPNet 말고도 MobileNet, Inception, SqueezeNet등 모델을 경량화 시키기 위한 논문에서 실험적으로 효과가 증명되었다.

<br/>

![ESPDi](https://user-images.githubusercontent.com/47741696/102000542-cac92500-3d2b-11eb-8e5d-534fb081d115.gif)

Spatial pyramid of dilated convolutions를 이해하기 위해서는 Dilated convolution에 대해서 이해를 해야한다. 위의 그림처럼 커널 사이에 간격을 줬다고 할 수 있는데 이런 간격으로 인해서 같은 픽셀수로 더 넓은 **Receptive Field(필터가 한번에 보는 영역)**를 가지게 된다.  

그래서 Dilated convolution은 dilation rate라는 커널 사이의 간격을 정의하는 파라미터를 사용하는데 위의 그림은 dilation rate가 2고 3x3 커널의 9개 파라미터를 사용하여 5x5 커널과 같은 Receptive Field를 가지고 있는것을 확인 할 수 있다.

※필터를 크게하면 연산량이 높아져서 계산량이 늘어난다. 그래서 일반적인 CNN에서는 pooling을 사용하여서 해결하려는 경향이 있는데 기존 정보의 손실이 크다. 하지만 Dilated convolution을 사용하면 같은 연산량으로 Receptive Fied를 크게 가져 갈 수 있어서 좋은 연산 효율을 가질 수 있다.

<br/>

### ESP module

![ESP4](https://user-images.githubusercontent.com/47741696/102000809-73788400-3d2e-11eb-9d74-5008ca064084.PNG)

이제 이 Paper가 제안하는 ESP module에 대해서 이해하기가 좀 더 편하다. 사실 이 부분만 잘 이해해도 ESPNet을 이해하고 활용할 수 있다.  그림에서 보면 **입력단에서 Dilation rate가 k-1(1, ... ,K)인 Dilated convolution 여러개를 단계적으로 합하여 최종 Sum을 내보내는 것**을 확인 할 수 있다. 이 방법으로 Accuracy를 유지하면서 파라미터와 메모리의 수를 많이 줄였다고 제안하고 있다.

<br/>

```
class DilatedParllelResidualBlockB(nn.Module):

    def __init__(self, nIn, nOut, add=True):

        super().__init__()
        n = int(nOut / 5)
        n1 = nOut - 4 * n
        self.c1 = C(nIn, n, 1, 1)
        self.d1 = CDilated(n, n1, 3, 1, 1)  # dilation rate of 2^0
        self.d2 = CDilated(n, n, 3, 1, 2)  # dilation rate of 2^1
        self.d4 = CDilated(n, n, 3, 1, 3)  # dilation rate of 2^2
        self.d8 = CDilated(n, n, 3, 1, 4)  # dilation rate of 2^3
        self.d16 = CDilated(n, n, 3, 1, 5)  # dilation rate of 2^4
        self.bn = BR(nOut)
        self.add = add

    def forward(self, input):

        # reduce
        output1 = self.c1(input)
        # split and transform
        d1 = self.d1(output1)
        d2 = self.d2(output1)
        d4 = self.d4(output1)
        d8 = self.d8(output1)
        d16 = self.d16(output1)

        # heirarchical fusion for de-gridding
        add1 = d2
        add2 = add1 + d4
        add3 = add2 + d8
        add4 = add3 + d16

        # merge
        combine = torch.cat([d1, add1, add2, add3, add4], 1)

        # if residual version
        if self.add:
            combine = input + combine
        output = self.bn(combine)
        return output

```

그림으로 이해가 안되는 부분은 Pytorch 코드로 확인 할 수 있는데 foward부분을 확인하면 **input을 Dilation rate가 2의 0승부터 4승까지 Dilated convolution을 하여 각각 d1,d2,d4,d8,d16(숫자는 Receptive Field의 크기)에  저장**을 한다. 그리고  combine = torch.cat([d1, add1, add2, add3, add4], 1)으로 더해줘서 최종 값을 output하는 것을 확인할 수 있다.  

<br/>

#### ESP_Encoder

![ESPen](https://user-images.githubusercontent.com/47741696/102001023-855b2680-3d30-11eb-953f-341a43976de0.jpg)

#### ESP_Decoder

![ESPde](https://user-images.githubusercontent.com/47741696/102001024-87bd8080-3d30-11eb-9c43-90c2e9f0434d.jpg)

ESPNet의 전체적인 진행을 480x400의 Image로 학습을 했다고 가정하여 Encoder와 Decoder로 나눠서 그림으로 그려봤다. 이해가 안되는 부분이 있으면 이 그림을 참고하여 이해를 하면 된다.

<br/>

![ESP2](https://user-images.githubusercontent.com/47741696/102001014-652b6780-3d30-11eb-8dcc-976722133275.PNG)

결과를 보면 파라미터와 Memory를 줄이는 아이디어를 제안한 다른 논문들과 비교를 해보면 ESPNet이 가장 큰 Receptive Field를 가지면서 낮은 parameters와 가장 낮은 Memory를 확인할 수 있다.

<br/>

~링크~

이 논문을 이용해서 교내 주차장 Segmentation을 한 결과를 올려보았다.